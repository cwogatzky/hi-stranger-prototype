Ziel: Server = Source of Truth, Browser = Runtime-Cache, NDJSON-Import, Schema-Validation, Read-APIs, Sync, danach Profile & Kalibrierung.

⸻

Schritt 1 — JSON Schema (user_profile.v1)

Was: Exaktes Ajv-kompatibles Schema für NDJSON-Import.
Warum: Klare Datenverträge, robuste Validierung, spätere Migrationen planbar.
Ich mache: Liefere user_profile.v1.schema.json (fertig), kurze Testhinweise.
Du machst: Datei in /docs/schemas/ ablegen (oder gewünschten Pfad sagen).
Status: Schon erstellt in vorigem Schritt; wir können direkt verifizieren oder übernehmen.

⸻

Schritt 2 — Import-Endpoint-Rahmen

Was: HTTP-Contract für POST /profiles/import (NDJSON / NDJSON.GZ).
Warum: Einheitlicher Vertrag für Admin-UI, Automations, Backend; Grundlage für Parser & Persistenz.
Ich mache: Exakte Request-/Response-Spezifikation, Statuscodes, Header, Beispiel-Bodies.
Du machst: “Go 2.1” bestätigen → ich liefere den Contract-Text; danach “Go 2.2” für Parsing-Flow.

⸻

Schritt 3 — Streaming & Parsing (Server)

Was: Zeilenweises Lesen, optional Gzip, Ajv-Validation pro Zeile.
Warum: Große Dateien, Teil-Erfolg möglich, klares Fehlerhandling.
Ich mache: Implementierungs-Skelett (ohne Provider-spezifische SDKs), klare Einbaupunkte.
Du machst: “Go 3” → ich liefere Code-Patch + genaue Einbauanweisung.

⸻

Schritt 4 — Persistenz-Pipeline

Was: R2/S3 (Raw), SQL/D1 (Index), KV (Hot-Cache), Upsert & rev/hash.
Warum: Skalierbar, auditierbar, schnelle Reads.
Ich mache: Tabellenschema/Keys, Upsert-Regeln, minimaler DAL-Code.
Du machst: “Go 4”.

⸻

Schritt 5 — Read-APIs & Delta-Feed

Was: GET /profiles/:id, GET /profiles?cursor, GET /profiles/changes?since_rev, optional SSE.
Warum: Cache-freundliche Reads, 304 via ETag, effizientes Nachladen.
Ich mache: Endpoints + Beispiele.
Du machst: “Go 5”.

⸻

Schritt 6 — Client Runtime-Cache (IndexedDB)

Was: /state/profileCache.js (get/put/markPending/applyDelta, base_snapshot).
Warum: Sofortiges Laden, Offline-Fallback, weniger API-Load.
Ich mache: Modul-Code + Integrationshinweise in Boot-Sequenz.
Du machst: “Go 6”.

⸻

Schritt 7 — Sync & Konfliktlösung

Was: If-Match/rev, 3-Way-Merge (base/local/server), Recompute behavior_vector.
Warum: Konsistenz bei gleichzeitigen Änderungen.
Ich mache: Merge-Logik + UI-Hinweise (Badge/Modal).
Du machst: “Go 7”.

⸻

Schritt 8 — Migration (Prototype → Server)

Was: Exporter (Browser → NDJSON), Admin-Upload, Roundtrip-Check.
Warum: Bestehende Daten sauber übernehmen.
Ich mache: Export-Snippet + NDJSON-Beispielbundle.
Du machst: “Go 8”.

⸻

Schritt 9 — Tests & Observability

Was: Testmatrix (Happy/Mixed/Invalid/Gzip/Idempotenz/Auth/Limits), Basis-Metriken.
Warum: Regressionssicher & messbar.
Ich mache: Testfälle + Metrik-Liste.
Du machst: “Go 9”.

⸻

Schritt 10 — Dokumentation (am Ende)

Was: DATA_STORAGE_CONCEPT.md (inkl. „Profile Import & Sync Workflow“), README, SCRIPT_ARCHITECTURE, SECURITY_PRIVACY, API-Referenz.
Warum: Team-ready, auditierbar, reproduzierbar.
Ich mache: fertige Textbausteine/Dateien.
Du machst: “Go 10”.