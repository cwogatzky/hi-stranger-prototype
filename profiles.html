<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Hi Stranger — Profiles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./styles.css" />
  <style>
    :root{
      --ui-font: 14px/1.4 system-ui, Segoe UI, Roboto, Arial, sans-serif;
      --muted:#6b7280; --border:#e5e7eb; --bg:#fff; --ink:#111827;
      --sidebar-w: 340px;
    }
    *{box-sizing:border-box}
    body{margin:0;background:#fff;color:#111}
    /* Topnav (unverändert) */
    .topnav{font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#f8fafc;border-bottom:1px solid #e5e7eb;padding:8px 12px}
    .topnav a{color:#111;text-decoration:none;margin-right:12px}
    .topnav a:hover{text-decoration:underline}
    /* Banner (unverändert) */
    .banner{background:#f3f4f6;border-bottom:1px solid #e5e7eb;padding:6px 10px;font:6pt/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif;color:#111827}
    .banner .sep{color:#6b7280;padding:0 6px}

    /* 2-Spalten Layout */
    .wrap{display:flex;gap:16px;max-width:1200px;margin:16px auto;padding:0 16px;align-items:flex-start}
    .left{width:var(--sidebar-w);flex:0 0 var(--sidebar-w)}
    .right{flex:1;min-width:0}

    /* Karten/Boxen links */
    .card{background:#fff;border:1px solid var(--border);border-radius:10px;padding:10px}
    .stack{display:flex;flex-direction:column;gap:12px}
    .h-row{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .label{font:12px/1.2 var(--ui-font);color:var(--muted)}
    .value{font-weight:600}
    .subtle{font:12px/1.4 var(--ui-font);color:var(--muted)}
    .small{font:12px/1.4 var(--ui-font)}
    .tiny{font:11px/1.2 var(--ui-font);color:var(--muted)}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

    /* Filter kompakt */
    .filter-grid{display:grid;grid-template-columns:1fr;gap:10px}
    .filter-row{display:flex;align-items:center;gap:8px}
    .filter-row label{font:12px/1.2 var(--ui-font);color:#111827;min-width:120px}
    .filter-row .hint{color:var(--muted)}
    .filter-row input[type="range"]{flex:1}
    fieldset{border:none;padding:0;margin:2px 0 0}
    legend{font:12px/1.2 var(--ui-font);margin:0 0 6px}
    .chk-group{display:flex;gap:10px;flex-wrap:wrap}
    .pill{display:inline-flex;align-items:center;gap:6px}

    /* Buttons / Inputs */
    .btn{appearance:none;border:1px solid #111827;background:#111827;color:#fff;padding:8px 12px;border-radius:999px;cursor:pointer;font:12px/1 var(--ui-font)}
    .btn.secondary{background:#fff;color:#111827}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    input[type="number"],input[type="text"]{font:12px/1 var(--ui-font);padding:8px;border:1px solid var(--border);border-radius:8px}
    input[type="number"]{width:90px}
    input[type="text"]{width:220px}

    /* Rechte Spalte: Matchinfo + Kartenliste */
    .match-info{margin:0 0 8px;font:12px/1.3 var(--ui-font);color:#374151}
    .cards{display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:12px}
    .card.profile{border:1px solid var(--border);border-radius:10px;padding:10px}
    .card.profile h4{margin:0 0 6px;font:14px/1.2 var(--ui-font)}
    .meta{font:12px/1.3 var(--ui-font);color:var(--muted);margin:3px 0}
    .row-btns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    /* === Compact list & toolbar === */
    .toolbar {
      display:flex; align-items:center; gap:12px; justify-content:space-between;
      padding:8px 0; border-bottom:1px solid #e5e7eb; margin-bottom:8px;
      font: 12px/1.4 system-ui, Segoe UI, Roboto, Arial, sans-serif;
    }
    .toolbar-left { display:flex; align-items:center; gap:12px; }
    .toolbar-right{ display:flex; align-items:center; gap:8px; }
    .icon-btn { background:none; border:none; cursor:pointer; padding:4px; color:#444; }
    .icon-btn .solid { display:none; }
    .icon-btn:hover .outline { display:none; }
    .icon-btn:hover .solid { display:inline; }
    .icon-btn:hover { color:#b91c1c; }
    .icon { width:18px; height:18px; vertical-align:middle; }

    .table-profiles { width:100%; border-collapse:collapse; font-size:12px; }
    .table-profiles th, .table-profiles td {
      border-bottom:1px solid #e5e7eb; padding:6px 8px; text-align:left;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .table-profiles th { font-weight:600; color:#111; background:#fafafa; }
    .table-profiles td.actions a { margin-right:10px; text-decoration:none; color:#111; }
    .table-profiles td.actions a:hover { text-decoration:underline; }
    .badge-meta { color:#6b7280; }

    /* (Altes Modal-CSS kann bleiben, wird aber nicht mehr verwendet) */
    .modal-backdrop{ position:fixed; inset:0; background:rgba(17,24,39,.55); display:none; z-index:9998; }
    .modal-backdrop.active{ display:block; }
    .modal{ position:fixed; z-index:9999; top:180px; right:180px; bottom:180px; left:180px; background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 20px 50px rgba(0,0,0,.25); display:flex; flex-direction:column; overflow:hidden; }
    .modal-header{ padding:12px 14px; border-bottom:1px solid #e5e7eb; display:flex; align-items:center; justify-content:space-between; font:14px/1.3 system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    .modal-title{ font-weight:600; color:#111827; }
    .modal-close{ background:none; border:none; cursor:pointer; font-size:18px; line-height:1; color:#6b7280; padding:4px 6px; border-radius:6px; }
    .modal-close:hover{ background:#f3f4f6; color:#111; }
    .modal-body{ flex:1; overflow:auto; padding:14px; font:13px/1.5 system-ui, Segoe UI, Roboto, Arial, sans-serif; color:#111827; }
    .modal-actions{ padding:12px 14px; border-top:1px solid #e5e7eb; display:flex; gap:8px; justify-content:flex-end; }
    .modal-actions .btn{ font:12px/1 var(--ui-font); padding:8px 12px; border-radius:8px; }
    .modal-actions .btn.secondary{ background:#fff; color:#111827; border:1px solid #d1d5db; }
    .modal-actions .btn.primary{ background:#111827; color:#fff; border:1px solid #111827; }

    /* === PROFILE EDITOR LAYER (Lightbox) === */
    .layer-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.45); backdrop-filter:blur(2px); z-index:9998; display:flex; align-items:center; justify-content:center; }
    .layer-box{ background:#fff; border:1px solid #e5e7eb; border-radius:12px; box-shadow:0 12px 32px rgba(0,0,0,.18); width:min(960px, calc(100vw - 360px)); max-height:calc(100vh - 360px); overflow:auto; padding:24px 28px; font:14px/1.5 system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    .layer-header{ display:flex; align-items:center; justify-content:space-between; padding-bottom:10px; margin-bottom:12px; border-bottom:1px solid #f3f4f6; }
    .layer-header h2{ margin:0; font-size:18px; font-weight:600; color:#111827; }
    .layer-close{ appearance:none; background:none; border:none; cursor:pointer; font-size:22px; line-height:1; color:#6b7280; }
    .layer-close:hover{ color:#111827; }
    .layer-body{ display:grid; grid-template-columns:1fr; gap:16px; }
    .layer-section{ padding-top:8px; border-top:1px solid #f3f4f6; }
    .layer-section:first-child{ border-top:none; padding-top:0; }
    .layer-section h3{ margin:0 0 8px; font-size:15px; font-weight:600; color:#111827; }
    .layer-field{ margin-bottom:10px; }
    .layer-field label{ display:block; font-size:12px; color:#374151; margin:0 0 4px; }
    .layer-field input[type="text"],
    .layer-field input[type="number"],
    .layer-field input[type="date"],
    .layer-field textarea,
    .layer-field select{ width:100%; padding:8px 10px; border:1px solid #e5e7eb; border-radius:8px; font:inherit; color:#111827; background:#fff; }
    .layer-field textarea{ min-height:72px; resize:vertical; }
    .layer-field .inline{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .layer-hint{ font-size:12px; color:#6b7280; }
    .layer-actions{ display:flex; gap:10px; justify-content:flex-end; border-top:1px solid #f3f4f6; padding-top:12px; margin-top:8px; }
    /* === Collapsible: Editor-Sektionen === */
    .layer-controls{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-bottom:12px;
    }

    .layer-section-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      cursor:pointer;
      padding:6px 0;
    }

    .layer-section-title{
      margin:0;
      font-size:15px;
      font-weight:600;
      color:#111827;
    }

    .toggle-btn{
      background:none;
      border:none;
      color:#6b7280;
      font-size:16px;
      line-height:1;
      cursor:pointer;
      padding:2px 6px;
      border-radius:6px;
    }
    .toggle-btn:hover{ color:#111827; background:#f3f4f6; }

    .layer-section-body{ display:block; }
    .layer-section.collapsed .layer-section-body{ display:none; }
    @media (max-width: 860px){
      .layer-box{ width:calc(100vw - 32px); max-height:calc(100vh - 32px); padding:18px 16px; }
    }
  
    .editor-section.collapsed > *:not(h3) { display:none; }
.editor-section h3 {
  cursor:pointer;
  position:relative;
  padding-right:24px;
}
.editor-section h3::after {
  content:'▸';
  position:absolute;
  right:4px;
  top:0;
  color:#9ca3af;
  font-size:14px;
  transform:rotate(0deg);
  transition:transform .2s;
}
.editor-section:not(.collapsed) h3::after {
  transform:rotate(90deg);
}
.editor-toolbar {
  display:flex;
  justify-content:flex-end;
  margin-bottom:10px;
}
.editor-toolbar button {
  border:1px solid #d1d5db;
  border-radius:6px;
  background:#fff;
  padding:4px 10px;
  cursor:pointer;
  font:12px/1.3 system-ui,Segoe UI,Roboto,Arial;
}  
    </style>
</head>
<body>
  <!-- Top-Navigation -->
  <nav class="topnav">
    <a href="/">Prototype</a>
    <a href="/profiles" aria-current="page"><strong>Profiles</strong></a>
    <a href="/docs/">Docs ↗</a>
  </nav>

  <!-- Info-Balken -->
  <div class="banner">
    <span>Core: NDJSON Import, Schema Validation, KV Persistence</span>
    <span class="sep">|</span>
    <span>Profiles in KV: <span id="kvCount" class="value">—</span></span>
    <span class="sep">|</span>
    <span>Last import: <span id="lastImport" class="subtle">—</span></span>
  </div>

  <main class="wrap">
    <aside class="left stack">
      <section class="card stack" aria-label="Filter & Overview">
        <div class="h-row">
          <div class="label">Profiles total</div>
          <div id="profileCount" class="value">Loading…</div>
        </div>

        <div class="h-row">
          <label class="pill tiny" style="margin:0;">
            <input type="checkbox" id="filtersEnabled"> Filters active
          </label>
          <button id="btnResetFilters" class="btn secondary">Reset</button>
        </div>

        <div class="filter-grid">
          <div class="filter-row">
            <label for="filterAssertiveness">Assertiveness:</label>
            <input type="range" id="filterAssertiveness" min="0" max="5" value="0">
            <span id="valAssertiveness" class="hint small">any</span>
          </div>

          <div class="filter-row">
            <label for="filterEmpathy">Empathy:</label>
            <input type="range" id="filterEmpathy" min="0" max="5" value="0">
            <span id="valEmpathy" class="hint small">any</span>
          </div>

          <div class="filter-row">
            <label for="filterStress">Stress Tolerance:</label>
            <input type="range" id="filterStress" min="0" max="5" value="0">
            <span id="valStress" class="hint small">any</span>
          </div>

          <fieldset>
            <legend>Emotional Regulation</legend>
            <div class="chk-group tiny">
              <label><input type="checkbox" class="chkReg" value="calm" checked> calm</label>
              <label><input type="checkbox" class="chkReg" value="sensitive" checked> sensitive</label>
              <label><input type="checkbox" class="chkReg" value="volatile" checked> volatile</label>
            </div>
          </fieldset>
        </div>
      </section>

      <section class="card stack" aria-label="Generate & Upload">
        <div class="h-row"><div class="label" style="color:#111827;font-weight:600">Generate & Upload</div></div>
        <div class="controls">
          <label class="tiny">How many:</label>
          <input id="genCount" type="number" min="1" max="2000" value="10" />
          <label class="tiny">Auth:</label>
          <input id="authToken" type="text" value="admin_local" />
          <button id="btnGenerateUpload" class="btn">Generate & Upload</button>
        </div>
        <div class="controls">
          <input id="fileInput" type="file" accept=".ndjson,.txt,application/x-ndjson" />
          <button id="btnUploadFile" class="btn secondary">Upload NDJSON</button>
        </div>
        <p id="uploadStatus" class="tiny">Status: —</p>
      </section>
    </aside>

    <section class="right">
      <p id="matchInfo" class="match-info">Showing — of — profiles</p>

      <div class="toolbar">
        <div class="toolbar-left">
          <label><input type="checkbox" id="chkSelectAll"> Select all</label>
          <span class="badge-meta">Selected: <span id="bulkCount">0</span></span>
        </div>
        <div class="toolbar-right">
          <span class="badge-meta">Chat enabled: <span id="chatEnabledInfo">0</span></span>
          <button id="btnBulkDelete" class="icon-btn" title="Delete selected" disabled>
            <svg class="icon outline" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="3 6 5 6 21 6"/>
              <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
              <path d="M10 11v6M14 11v6"/>
              <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/>
            </svg>
            <svg class="icon solid" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
              <path d="M9 3a2 2 0 0 0-2 2v1H4a1 1 0 1 0 0 2h1l1 12a3 3 0 0 0 3 3h6a3 3 0 0 0 3-3l1-12h1a1 1 0 1 0 0-2h-3V5a2 2 0 0 0-2-2H9zM10 11a1 1 0 0 1 2 0v6a1 1 0 1 1-2 0v-6zm4 0a1 1 0 1 1 2 0v6a1 1 0 1 1-2 0v-6z"/>
            </svg>
          </button>
        </div>
      </div>

      <div id="cards" class="cards">
        <div class="muted">Loading…</div>
      </div>
    </section>
  </main>

  <script>
    const $ = function (s){ return document.querySelector(s); };

    // SAFE: DOM-basierter Encoder
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = String(text == null ? '' : text);
      return div.innerHTML;
    }

    // Counts
    const kvCountEl      = $('#kvCount');
    const profileCountEl = $('#profileCount');
    function setCounts(total){
      const txt = String(total);
      if (kvCountEl) kvCountEl.textContent = txt;
      if (profileCountEl) profileCountEl.textContent = txt;
    }

    const lastImportEl   = $('#lastImport');
    const uploadStatus   = $('#uploadStatus');
    const matchInfoEl    = $('#matchInfo');
    const cardsEl        = $('#cards');

    // Slider live readout
    document.addEventListener('input', function (e) {
      const el = e.target;
      if (!(el instanceof HTMLInputElement)) return;
      if (el.type !== 'range') return;
      const key = el.id ? el.id.replace('fld_','') : '';
      if (!key) return;
      const ro = document.querySelector('.range-readout[data-for="' + key + '"]');
      if (ro) ro.textContent = el.value;
    });

    const filtersEnabled = $('#filtersEnabled');
    const btnResetFilters= $('#btnResetFilters');
    const slAssert       = $('#filterAssertiveness');
    const slEmpathy      = $('#filterEmpathy');
    const slStress       = $('#filterStress');
    const valAssert      = $('#valAssertiveness');
    const valEmp         = $('#valEmpathy');
    const valStress      = $('#valStress');
    const chkRegs        = Array.from(document.querySelectorAll('.chkReg'));

    const genCountEl     = $('#genCount');
    const authTokenEl    = $('#authToken');
    const fileInput      = $('#fileInput');
    const btnGenUp       = $('#btnGenerateUpload');
    const btnUpFile      = $('#btnUploadFile');

    // Toolbar
    const chkSelectAll   = document.querySelector('#chkSelectAll');
    const btnBulkDelete  = document.querySelector('#btnBulkDelete');
    const bulkCountEl    = document.querySelector('#bulkCount');
    const chatEnabledInfo= document.querySelector('#chatEnabledInfo');

    // Auswahl-Zustände
    let SELECTED_IDS = new Set();
    let CHAT_ENABLED_IDS = new Set();
    let CHAT_MAP = new Map();
    function syncChatLocalStorage(){
      try {
        const arr = Array.from(CHAT_MAP.values());
        localStorage.setItem('chat_injected_profiles', JSON.stringify(arr));
      } catch(e) {
        console.warn('localStorage sync failed', e);
      }
    }
    function initChatFromLocal(){
      CHAT_ENABLED_IDS.clear();
      CHAT_MAP.clear();
      try {
        const raw = localStorage.getItem('chat_injected_profiles');
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          for (var i=0;i<arr.length;i++){
            const obj = arr[i];
            const id = obj && obj.profile_id;
            if (id) {
              CHAT_ENABLED_IDS.add(id);
              CHAT_MAP.set(id, obj);
            }
          }
        }
      } catch(e){}
    }

    let ALL_IDS = [];
    let ALL_PROFILES = [];
    let FILTERS = {
      assertiveness: 0, empathy: 0, stress: 0,
      regulation: new Set(['calm','sensitive','volatile'])
    };
    // === Profile Fields & Options (Quelle für Editor) ===
// 1) Zentrale Options-/Label-Quelle
window.getProfileOptions = function(name){
  var maps = {
    // --- INTENT ---
    expectations: {
      deep_connection: 'Deep connection',
      meaningful_conversations: 'Meaningful conversations',
      personal_growth: 'Personal growth',
      mainly_fun: 'Mainly fun',
      professional_mentorship: 'Professional mentorship',
      advice: 'Advice',
      create_community: 'Create a community',
      just_checking: 'Just checking'
    },
    conversation_goals: {
      deepen_understanding: 'Deepen understanding',
      explore_new_perspectives: 'Explore new perspectives',
      build_empathy: 'Build empathy',
      practice_language: 'Practice language',
      gain_advice: 'Gain advice',
      develop_self_awareness: 'Develop self-awareness',
      enjoy_casual_talk: 'Enjoy casual talk'
    },
    values_and_beliefs: {
      loyalty_trust: 'Loyalty & Trust',
      honest_open_comm: 'Honest & Open Communication',
      humor_playfulness: 'Sense of Humor & Playfulness',
      intellectual_stimulation: 'Intellectual Stimulation & Deep Conversations',
      cultural_curiosity: 'Cultural Curiosity & Openness to Diversity',
      personal_growth_ambition: 'Personal Growth & Ambition',
      spontaneity_adventure: 'Spontaneity & Adventure'
    },
    topics_to_avoid: {
      politics: 'Political debates',
      religion: 'Religious or spiritual topics',
      polarizing: 'Controversial or polarizing topics',
      toxic_behavior: 'Trolling or toxic behavior',
      conspiracy: 'Conspiracy theories',
      unverified_health: 'Unverified health & wellness claims'
    },

    // --- BEHAVIOR ---
    social_energy: {
      social_events_new_people: 'Enjoys social events & new people',
      small_close_group: 'Prefers small close group',
      solitary_creative_work: 'Solitary/creative work',
      lead_conversations: 'Leads conversations',
      prefer_listening_value_add: 'Prefers listening, adds value',
      overwhelmed_large_pref_1to1: 'Overwhelmed by large groups, prefers 1-to-1'
    },
    communication_style: {
      open_direct: 'Open & direct',
      more_structured: 'More structured',
      casual_quick: 'Casual & quick',
      selective_engagement: 'Selective engagement'
    },
    conflict_response: {
      direct_resolution: 'Direct resolution',
      reflective_delayed: 'Reflective & delayed',
      avoidant: 'Avoidant'
    },
    support_style: {
      practical_problem_solving: 'Practical problem solving',
      empathetic_listening: 'Empathetic listening',
      humor_distraction: 'Humor & distraction'
    },
    decision_style: {
      structured: 'Structured',
      adaptive: 'Adaptive',
      impulsive: 'Impulsive'
    },

    // --- EMOTIONAL ---
    emotional_needs: {
      availability_trust: 'Availability & trust',
      shared_interests_experiences: 'Shared interests & experiences',
      consistency_reliability: 'Consistency & reliability'
    },
    maintenance_style: {
      regular_deep_checkins: 'Regular deep check-ins',
      spontaneous_connection: 'Spontaneous connection',
      intermittent_but_reliable: 'Intermittent but reliable'
    },
    emotional_regulation: {
      calm: 'Calm',
      sensitive: 'Sensitive',
      volatile: 'Volatile'
    },

    // --- INTERESTS ---
    shared_lifestyle_type: {
      creative_intellectual: 'Engaging in intellectual/creative projects',
      adventurous_exploratory: 'Exploring new places & adventurous activities',
      relaxed_playful: 'Relaxing settings & lighthearted fun'
    },

    // --- SCALE LABELS (1..5) ---
    assertiveness_level_labels: {
      1:'very low',2:'low',3:'medium',4:'high',5:'very high'
    },
    empathy_depth_labels: {
      1:'very low',2:'low',3:'medium',4:'high',5:'very high'
    },
    stress_tolerance_labels: {
      1:'very low',2:'low',3:'medium',4:'high',5:'very high'
    }
  };
  return maps[name] || null;
};

// 2) Felddefinitionen für den Editor (inkl. UI-Typ, Required, Options/Labels)
window.PROFILE_FIELDS = [
  // --- Identity ---
  { key:'user_name',        path:'profile.identity.user_name',        type:'text',           required:true },
  { key:'gender',           path:'profile.identity.gender',           type:'select',         required:false, options:['m','f','nonbinary','prefer_not_to_say'] },
  { key:'birthday',         path:'profile.identity.birthday',         type:'date',           required:false },
  { key:'age',              path:'profile.identity.age',              type:'number-readonly',required:false },
  { key:'avatar_picture',   path:'profile.identity.avatar_picture',   type:'file-url',       required:false },
  { key:'system_language',  path:'profile.identity.system_language',  type:'text',           required:false },

  // --- Intent ---
  { key:'expectations',       path:'profile.intent.expectations',       type:'checkbox-group', required:true,  options:'expectations' },
  { key:'biography',          path:'profile.intent.biography',          type:'textarea',       required:false, maxLength:800 },
  { key:'conversation_goals', path:'profile.intent.conversation_goals', type:'checkbox-group', required:true,  options:'conversation_goals' },
  { key:'values_and_beliefs', path:'profile.intent.values_and_beliefs', type:'checkbox-group', required:true,  options:'values_and_beliefs' },
  { key:'topics_to_avoid',    path:'profile.intent.topics_to_avoid',    type:'checkbox-group', required:false, options:'topics_to_avoid' },

  // --- Behavior ---
  { key:'social_energy',       path:'profile.behavior.social_energy',       type:'checkbox-group', required:true,  options:'social_energy' },
  { key:'communication_style', path:'profile.behavior.communication_style', type:'checkbox-group', required:true,  options:'communication_style' },
  { key:'conflict_response',   path:'profile.behavior.conflict_response',   type:'radio',          required:false, options:'conflict_response' },
  { key:'support_style',       path:'profile.behavior.support_style',       type:'radio',          required:false, options:'support_style' },
  { key:'assertiveness_level', path:'profile.behavior.assertiveness_level', type:'range-1-5',      required:true,  labels:'assertiveness_level_labels' },
  { key:'decision_style',      path:'profile.behavior.decision_style',      type:'radio',          required:true,  options:'decision_style' },

  // --- Emotional ---
  { key:'emotional_needs',     path:'profile.emotional.emotional_needs',   type:'checkbox-group', required:true,  options:'emotional_needs' },
  { key:'maintenance_style',   path:'profile.emotional.maintenance_style', type:'checkbox-group', required:true,  options:'maintenance_style' },
  { key:'emotional_regulation',path:'profile.emotional.emotional_regulation', type:'radio',       required:true,  options:'emotional_regulation' },
  { key:'empathy_depth',       path:'profile.emotional.empathy_depth',     type:'range-1-5',      required:true,  labels:'empathy_depth_labels' },
  { key:'stress_tolerance',    path:'profile.emotional.stress_tolerance',  type:'range-1-5',      required:true,  labels:'stress_tolerance_labels' },

  // --- Interests ---
  { key:'shared_lifestyle_type', path:'profile.interests.shared_lifestyle_type', type:'checkbox-group', required:true, options:'shared_lifestyle_type' },
  { key:'interests',             path:'profile.interests.interests',             type:'tags',           required:true }
];

// (Optional) Externer Helper zum Öffnen – falls woanders benötigt
window.openProfileEditor = window.openProfileEditor || function(profileObj){
  try {
    var html = buildProfileEditorHTML(profileObj);
    openLightboxWith(html);
  } catch(e){
    console.error('[openProfileEditor] failed:', e);
  }
};

    // API helpers
    async function safeJson(r){
      try { return await r.json(); }
      catch { return null; }
    }

    async function apiList(cursor, limit){
      if (typeof cursor === 'undefined') cursor = null;
      if (typeof limit === 'undefined') limit = 100;
      const u = new URL('/api/profiles', location.origin);
      if (cursor) u.searchParams.set('cursor', cursor);
      if (limit)  u.searchParams.set('limit', String(limit));
      const r = await fetch(u, { cache:'no-store' });
      if (!r.ok) throw new Error('List failed: HTTP ' + r.status);
      const data = await safeJson(r) || {};

      if (Array.isArray(data.items)) {
        return {
          ids: data.items.map(function(it){ return (it.id != null ? it.id : it.profile_id); }).filter(Boolean),
          next_cursor: data.next_cursor || null
        };
      }
      if (Array.isArray(data.keys)) {
        return { ids: data.keys, next_cursor: data.next_cursor || null };
      }
      if (Array.isArray(data.ids)) {
        return { ids: data.ids, next_cursor: data.next_cursor || null };
      }
      return { ids: [], next_cursor: null };
    }

    async function apiItem(id){
      const r = await fetch('/api/profiles/item?id=' + encodeURIComponent(id), { cache:'no-store' });
      if (!r.ok) throw new Error('Item failed (' + id + '): HTTP ' + r.status);
      const data = await safeJson(r);
      if (!data) throw new Error('Item parse failed (' + id + ')');
      return data;
    }

    async function apiImportNDJSON(ndjson, token){
      const r = await fetch('/api/profiles/import', {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + (token || 'admin_local'), 'Content-Type': 'application/x-ndjson' },
        body: ndjson
      });
      const body = await r.json().catch(function(){ return {}; });
      return { ok: r.ok, status: r.status, body: body };
    }

    // Count
    async function refreshKVCountOnly() {
      try {
        const r = await fetch('/api/profiles/count', { cache: 'no-store' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const data = await safeJson(r) || {};
        const total = (typeof data.total === 'number') ? data.total : (Array.isArray(data.keys) ? data.keys.length : 0);
        setCounts(total);
      } catch (e) {
        console.error('Count failed', e);
        setCounts('–');
      }
    }

    // Generator
    function generateProfiles(n){
      const out=[]; const nameCounter={};
      for(var i=0;i<n;i++){
        const id = 'usr_' + randBase36(8);
        const created = new Date().toISOString();
        const gender = pick(['m','f','nonbinary','prefer_not_to_say']);
        const year = 1978 + Math.floor(Math.random()*25);
        const month = String(1+Math.floor(Math.random()*12)).padStart(2,'0');
        const day   = String(1+Math.floor(Math.random()*28)).padStart(2,'0');
        const birthday = year + '-' + month + '-' + day;
        const age = Math.max(13, new Date().getUTCFullYear() - year);
        let baseName = sampleName(gender);
        nameCounter[baseName] = (nameCounter[baseName]||0)+1;
        const user_name = baseName + '_' + nameCounter[baseName];

        const profile = {
          identity:{ user_name:user_name, gender:gender, birthday:birthday, age:age, avatar_picture:null },
          intent:{
            expectations:[pick(['deep_connection','meaningful_conversations','personal_growth','mainly_fun','professional_mentorship','advice','create_community','just_checking'])],
            biography: pick(['Curious mind.','Likes quick chats.','Enjoys deep talks.']),
            conversation_goals:[pick(['deepen_understanding','explore_new_perspectives','build_empathy','practice_language','gain_advice','develop_self_awareness','enjoy_casual_talk'])],
            values_and_beliefs:[pick(['loyalty_trust','honest_open_comm','humor_playfulness','intellectual_stimulation','cultural_curiosity','personal_growth_ambition','spontaneity_adventure'])],
            topics_to_avoid:[pick(['politics','religion','polarizing','toxic_behavior','conspiracy','unverified_health'])]
          },
          behavior:{
            social_energy:[pick(['social_events_new_people','small_close_group','solitary_creative_work','lead_conversations','prefer_listening_value_add','overwhelmed_large_pref_1to1'])],
            communication_style:[pick(['open_direct','more_structured','casual_quick','selective_engagement'])],
            conflict_response: pick(['direct_resolution','reflective_delayed','avoidant']),
            support_style: pick(['practical_problem_solving','empathetic_listening','humor_distraction']),
            assertiveness_level: 1 + Math.floor(Math.random()*5),
            decision_style: pick(['structured','adaptive','impulsive'])
          },
          emotional:{
            emotional_needs:[pick(['availability_trust','shared_interests_experiences','consistency_reliability'])],
            maintenance_style:[pick(['regular_deep_checkins','spontaneous_connection','intermittent_but_reliable'])],
            emotional_regulation: pick(['calm','sensitive','volatile']),
            empathy_depth: 1 + Math.floor(Math.random()*5),
            stress_tolerance: 1 + Math.floor(Math.random()*5)
          },
          interests:{
            shared_lifestyle_type:[pick(['creative_intellectual','adventurous_exploratory','relaxed_playful'])],
            interests: pickN(['reading','art','music','coding','sports','travel','hiking','cooking'], 2)
          }
        };
        out.push({ schema_version:"user_profile.v1", profile_id:id, created_at:created, profile:profile });
      }
      return out;
    }
    function toNDJSON(arr){ return arr.map(function(o){ return JSON.stringify(o); }).join('\n'); }
    function pick(a){ return a[Math.floor(Math.random()*a.length)]; }
    function pickN(a,n){ const b=a.slice(); const o=[]; for(let i=0;i<n;i++){ o.push(b.splice(Math.floor(Math.random()*b.length),1)[0]); } return o; }
    function randBase36(n){ return Math.random().toString(36).slice(2,2+n); }
    function sampleName(g){
      const M=['Ben','Leo','Max','Tom','Noah','Finn'];
      const F=['Anna','Lia','Mia','Lea','Sara','Zoe'];
      const X=['Alex','Sam','Jamie','Robin','Charlie','Taylor'];
      if (g==='m') return pick(M);
      if (g==='f') return pick(F);
      return pick(X);
    }

    // Load data
    async function loadAllIdsAndCount(){
      ALL_IDS=[]; let cursor=null; let total=0;
      let safety = 0;
      do{
        const page = await apiList(cursor);
        const ids = page.ids || [];
        ALL_IDS.push.apply(ALL_IDS, ids);
        total += ids.length;
        cursor = page.next_cursor || null;
        safety++;
      } while (cursor && safety < 100);
      setCounts(total);
    }

    async function loadDetailsForIds(ids, batchSize){
      if (typeof batchSize === 'undefined') batchSize = 25;
      const out=[];
      for(let i=0;i<ids.length;i+=batchSize){
        const chunk = ids.slice(i,i+batchSize);
        const promises = chunk.map(function(id){ return apiItem(id); });
        const results = await Promise.allSettled(promises);
        for(let k=0;k<results.length;k++){
          const r = results[k];
          if(r.status==='fulfilled') out.push(r.value);
          else console.warn('[apiItem failed]', r.reason);
        }
      }
      return out;
    }

    async function loadData(){
      cardsEl.innerHTML = '<div class="subtle">Loading…</div>';
      try{
        await loadAllIdsAndCount();
        if (!ALL_IDS.length){
          renderMatchInfo(0, 0);
          renderCards([]);
          return;
        }
        ALL_PROFILES = await loadDetailsForIds(ALL_IDS);
        renderMatchInfo(ALL_PROFILES.length, ALL_IDS.length);
        applyFilterAndRender();
      } catch (err){
        console.error('[loadData] failed:', err);
        cardsEl.innerHTML = '<div class="subtle">Error loading profiles: ' + escapeHtml(err.message || String(err)) + '</div>';
      }
    }

    // Filters
    function readFilters(){
      const a = Number(slAssert && slAssert.value || 0);
      const e = Number(slEmpathy && slEmpathy.value || 0);
      const s = Number(slStress && slStress.value || 0);
      const regs = (chkRegs && chkRegs.length) ? chkRegs.filter(function(c){ return c.checked; }).map(function(c){ return c.value; }) : [];
      FILTERS.assertiveness = a; FILTERS.empathy = e; FILTERS.stress = s;
      FILTERS.regulation = new Set(regs.length ? regs : ['calm','sensitive','volatile']);
    }
    function renderMatchInfo(matched, total){
      matchInfoEl.textContent = 'Showing ' + matched + ' of ' + total + ' profiles';
    }
    function applyFilterAndRender(){
      readFilters();
      const active = !!(filtersEnabled && filtersEnabled.checked);
      const total = ALL_PROFILES.length;
      const filtered = ALL_PROFILES.filter(function(p){
        if (!active) return true;
        const b = p && p.profile && p.profile.behavior ? p.profile.behavior : {};
        const e = p && p.profile && p.profile.emotional ? p.profile.emotional : {};
        if (FILTERS.assertiveness && b.assertiveness_level !== FILTERS.assertiveness) return false;
        if (FILTERS.empathy && e.empathy_depth !== FILTERS.empathy) return false;
        if (FILTERS.stress && e.stress_tolerance !== FILTERS.stress) return false;
        if (e.emotional_regulation && !FILTERS.regulation.has(e.emotional_regulation)) return false;
        return true;
      });
      renderMatchInfo(filtered.length, total);
      renderCards(filtered);
    }

    // === Edit-Layer Renderer ===
    function buildProfileEditorHTML(profile) {
      const FIELDS = window.PROFILE_FIELDS || [];
      const getOpts = window.getProfileOptions;

      function getAt(obj, path) {
        if (!path) return undefined;
        const parts = path.split('.');
        var o = obj;
        for (var i=0;i<parts.length;i++){
          var k = parts[i];
          if (!o || !(k in o)) return undefined;
          o = o[k];
        }
        return o;
      }

      const rawBirthday = getAt(profile, 'profile.identity.birthday');
      const derivedAge = (function(){
        if (!rawBirthday) return '';
        const b = new Date(rawBirthday);
        if (Number.isNaN(+b)) return '';
        const now = new Date();
        var age = now.getFullYear() - b.getFullYear();
        const m = now.getMonth() - b.getMonth();
        if (m < 0 || (m === 0 && now.getDate() < b.getDate())) age--;
        return String(age);
      })();

      const sections = { Identity: [], Intent: [], Behavior: [], Emotional: [], Interests: [] };

      function sectionOf(key){
        if (['user_name','gender','birthday','age','avatar_picture','system_language'].indexOf(key) >= 0) return 'Identity';
        if (['expectations','biography','conversation_goals','values_and_beliefs','topics_to_avoid'].indexOf(key) >= 0) return 'Intent';
        if (['social_energy','communication_style','conflict_response','support_style','assertiveness_level','decision_style'].indexOf(key) >= 0) return 'Behavior';
        if (['emotional_needs','maintenance_style','emotional_regulation','empathy_depth','stress_tolerance'].indexOf(key) >= 0) return 'Emotional';
        if (['shared_lifestyle_type','interests'].indexOf(key) >= 0) return 'Interests';
        return 'Identity';
      }

      function renderField(f) {
        const curr = f.key === 'age' ? derivedAge : getAt(profile, f.path);
        const req = f.required ? ' data-required="true"' : '';
        const label = '<label class="fld-label" for="fld_' + f.key + '">' + f.key.replace(/_/g,' ') + '</label>';

        const opts = typeof f.options === 'string' ? getOpts(f.options) : null;
        const labels = typeof f.labels === 'string' ? getOpts(f.labels) : null;

        const currArr = Array.isArray(curr) ? curr : (curr == null ? [] : [curr]);

        switch (f.type) {
          case 'text':
            return '<div class="fld">' + label + '<input id="fld_' + f.key + '" type="text"' + req + ' value="' + (curr==null?'':curr) + '"></div>';
          case 'textarea':
            return '<div class="fld">' + label + '<textarea id="fld_' + f.key + '" rows="4"' + req + ' maxlength="' + (f.maxLength||800) + '">' + (curr==null?'':curr) + '</textarea></div>';
          case 'date':
            return '<div class="fld">' + label + '<input id="fld_' + f.key + '" type="date"' + req + ' value="' + (curr==null?'':curr) + '"></div>';
          case 'number-readonly':
            return '<div class="fld">' + label + '<input id="fld_' + f.key + '" type="number" value="' + (curr==null?'':curr) + '" readonly></div>';
          case 'file-url':
            return '<div class="fld">' + label + '<input id="fld_' + f.key + '" type="url" placeholder="https://..." value="' + (curr==null?'':curr) + '"></div>';
          case 'select': {
            const options = Array.isArray(opts) ? opts : [];
            const optsHtml = options.map(function(code){
              const sel = curr === code ? ' selected' : '';
              return '<option value="' + code + '"' + sel + '>' + (code && code.toUpperCase ? code.toUpperCase() : code) + '</option>';
            }).join('');
            return '<div class="fld">' + label + '<select id="fld_' + f.key + '"' + req + '>' + optsHtml + '</select></div>';
          }
          case 'radio': {
            const entries = opts ? Object.entries(opts) : [];
            const radios = entries.map(function(pair){
              const val = pair[0], lab = pair[1];
              const checked = String(curr) === String(val) ? ' checked' : '';
              return '<label class="choice"><input type="radio" name="grp_' + f.key + '" value="' + val + '"' + checked + '> ' + lab + '</label>';
            }).join('');
            return '<fieldset class="fld"><legend>' + f.key.replace(/_/g,' ') + '</legend>' + radios + '</fieldset>';
          }
          case 'checkbox-group': {
            const entries = opts ? Object.entries(opts) : [];
            const checks = entries.map(function(pair){
              const val = pair[0], lab = pair[1];
              const checked = currArr.indexOf(val) >= 0 ? ' checked' : '';
              return '<label class="choice"><input type="checkbox" name="grp_' + f.key + '" value="' + val + '"' + checked + '> ' + lab + '</label>';
            }).join('');
            return '<fieldset class="fld"><legend>' + f.key.replace(/_/g,' ') + '</legend>' + checks + '</fieldset>';
          }
          case 'range-1-5': {
            const val = (curr == null ? 3 : curr);
            const ticks = [1,2,3,4,5].map(function(n){
              const lab = (labels && labels[n]) ? (' (' + labels[n] + ')') : '';
              return '<option value="' + n + '" label="' + n + lab + '"></option>';
            }).join('');
            return '' +
              '<div class="fld">' +
                label +
                '<input id="fld_' + f.key + '" type="range" min="1" max="5" step="1" value="' + val + '" list="ticks_' + f.key + '">' +
                '<datalist id="ticks_' + f.key + '">' + ticks + '</datalist>' +
                '<div class="range-readout" data-for="' + f.key + '">' + val + '</div>' +
              '</div>';
          }
          case 'tags': {
            const val2 = Array.isArray(curr) ? curr.join(', ') : (curr == null ? '' : curr);
            return '<div class="fld">' + label + '<input id="fld_' + f.key + '" type="text" placeholder="comma, separated, tags" value="' + val2 + '"></div>';
          }
          default:
            return '<div class="fld">' + label + '<input id="fld_' + f.key + '" type="text" value="' + (curr==null?'':curr) + '"></div>';
        }
      }

      FIELDS.forEach(function(f){
        const sec = sectionOf(f.key);
        sections[sec].push(renderField(f));
      });

      // Collapsible-Abschnitte erzeugen
        const sectionsHtml = Object.keys(sections).map(function(sec){
          const items = sections[sec].join('');
          // Standard: eingeklappt -> Klasse "collapsed" setzen
          return '' +
            '<section class="layer-section collapsed" data-section="' + sec + '">' +
              '<div class="layer-section-header" data-toggle="section">' +
                '<h3 class="layer-section-title">' + sec + '</h3>' +
                '<button type="button" class="toggle-btn" aria-label="Toggle ' + sec + '">▸</button>' +
              '</div>' +
              '<div class="layer-section-body">' + items + '</div>' +
            '</section>';
        }).join('');
            const subtitle = (profile && profile.profile && profile.profile.identity && profile.profile.identity.user_name)
            ? profile.profile.identity.user_name
            : (profile && profile.profile_id ? profile.profile_id : '');

        // Head + Expand/Collapse Controls + Body + Foot
        const html =
          '<div class="editor-head">' +
            '<h2>Edit Profile</h2>' +
            '<div class="subtitle">' + escapeHtml(subtitle) + '</div>' +
          '</div>' +
          '<div class="layer-controls">' +
            '<button type="button" class="btn secondary" data-act="expand-all">Expand all</button>' +
            '<button type="button" class="btn secondary" data-act="collapse-all">Collapse all</button>' +
          '</div>' +
          '<div class="editor-body">' + sectionsHtml + '</div>' +
          '<div class="editor-foot">' +
            '<button type="button" id="btnEditorCancel">Cancel</button>' +
            '<button type="button" id="btnEditorSave" class="primary">Save</button>' +
          '</div>';

        return html;
    }

    // Lightbox styles once
    function injectEditorStylesOnce() {
      if (document.getElementById('profile-editor-styles')) return;
      const css = [
        '.lb-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.5);z-index:10000;display:flex;align-items:center;justify-content:center}',
        '.lb-dialog{background:#fff;border-radius:12px;max-width:1200px;width:calc(100% - 360px);max-height:calc(100% - 360px);padding:20px;overflow:auto;box-shadow:0 20px 48px rgba(0,0,0,.25)}',
        '.editor-head h2{margin:0 0 4px 0;font:600 18px/1.2 system-ui,Segoe UI,Roboto,Arial}',
        '.editor-head .subtitle{color:#6b7280;margin-bottom:12px}',
        '.editor-body{display:grid;grid-template-columns:1fr 1fr;gap:16px}',
        '.editor-section h3{margin:8px 0 8px 0;font:600 14px/1.2 system-ui,Segoe UI,Roboto,Arial}',
        '.fld{display:flex;flex-direction:column;gap:6px;margin:8px 0}',
        '.fld .fld-label{font:13px/1.2 system-ui,Segoe UI,Roboto,Arial;color:#111}',
        '.fld input[type="text"], .fld input[type="url"], .fld input[type="date"], .fld input[type="number"], .fld textarea, .fld select{border:1px solid #d1d5db;border-radius:8px;padding:8px 10px;font:14px system-ui,Segoe UI,Roboto,Arial}',
        'fieldset.fld{border:1px solid #e5e7eb;border-radius:8px;padding:8px 10px}',
        'fieldset.fld legend{padding:0 4px;font:600 12px/1.2 system-ui,Segoe UI,Roboto,Arial;color:#374151}',
        '.choice{display:inline-flex;align-items:center;gap:6px;margin:4px 10px 4px 0;font:13px system-ui,Segoe UI,Roboto,Arial}',
        '.range-readout{font:12px system-ui,Segoe UI,Roboto,Arial;color:#6b7280;margin-top:4px}',
        '.editor-foot{display:flex;justify-content:flex-end;gap:10px;margin-top:16px}',
        '.editor-foot button{border:1px solid #d1d5db;background:#fff;border-radius:999px;padding:8px 14px;font:14px system-ui,Segoe UI,Roboto,Arial;cursor:pointer}',
        '.editor-foot button.primary{background:#2563eb;border-color:#2563eb;color:#fff}',
        '@media (max-width:1024px){.lb-dialog{width:calc(100% - 40px);max-height:calc(100% - 40px)}.editor-body{grid-template-columns:1fr}}'
      ].join('\n');
      const style = document.createElement('style');
      style.id = 'profile-editor-styles';
      style.textContent = css;
      document.head.appendChild(style);
    }

    function ensureLightboxRoot() {
      var root = document.getElementById('lb-root');
      if (!root) {
        root = document.createElement('div');
        root.id = 'lb-root';
        document.body.appendChild(root);
      }
      return root;
    }

    function openLightboxWith(html) {
      injectEditorStylesOnce();
      const root = ensureLightboxRoot();
      root.innerHTML =
        '<div class="lb-backdrop" id="lb-backdrop">' +
          '<div class="lb-dialog" role="dialog" aria-modal="true">' +
            html +
          '</div>' +
        '</div>';
      root.querySelector('#lb-backdrop').addEventListener('click', function (e) {
        if (e.target.id === 'lb-backdrop') closeLightbox();
      });
      const btnCancel = root.querySelector('#btnEditorCancel');
      if (btnCancel) btnCancel.addEventListener('click', closeLightbox);
        // 1) Einzelnen Bereich ein/ausklappen (delegiert)
        const dlg = root.querySelector('.lb-dialog');
        dlg.addEventListener('click', function (ev) {
          const header = ev.target.closest('[data-toggle="section"]');
          if (!header) return;
          const section = header.closest('.layer-section');
          if (!section) return;
          const collapsed = section.classList.toggle('collapsed');

          // Pfeil-Zeichen aktualisieren (▸ eingeklappt, ▾ ausgeklappt)
          const btn = header.querySelector('.toggle-btn');
          if (btn) btn.textContent = collapsed ? '▸' : '▾';
        });

        // 2) Expand all / Collapse all
        dlg.addEventListener('click', function (ev) {
          const actEl = ev.target.closest('[data-act]');
          if (!actEl) return;
          const act = actEl.getAttribute('data-act');
          if (!act) return;

          const sections = dlg.querySelectorAll('.layer-section');
          if (act === 'expand-all') {
            sections.forEach(function (sec) {
              sec.classList.remove('collapsed');
              const btn = sec.querySelector('.toggle-btn');
              if (btn) btn.textContent = '▾';
            });
          } else if (act === 'collapse-all') {
            sections.forEach(function (sec) {
              sec.classList.add('collapsed');
              const btn = sec.querySelector('.toggle-btn');
              if (btn) btn.textContent = '▸';
            });
          }
        });

        // 3) Live-Readout für Range-Slider NUR innerhalb des Editors
        dlg.addEventListener('input', function (e) {
          const el = e.target;
          if (!(el instanceof HTMLInputElement)) return;
          if (el.type !== 'range') return;
          const key = el.id ? el.id.replace('fld_','') : '';
          if (!key) return;
          const ro = dlg.querySelector('.range-readout[data-for="' + key + '"]');
          if (ro) ro.textContent = el.value;
        });
    }

    function closeLightbox() {
      const root = document.getElementById('lb-root');
      if (root) root.innerHTML = '';
    }
    
    // === Editor: Auslesen, Validieren, Persistieren ===

// Tiefkopie (simpel & ausreichend hier)
function deepClone(obj){ return JSON.parse(JSON.stringify(obj || {})); }

// Wert eines Feldes nach Definition aus dem Lightbox-DOM lesen
function readFieldValue(def){
  var key = def.key;
  var id  = 'fld_' + key;

  // Gruppen (checkbox/radio) lesen wir über den gemeinsamen Namen:
  if (def.type === 'checkbox-group'){
    var name = 'grp_' + key;
    var nodes = document.querySelectorAll('input[name="'+name+'"]:checked');
    var vals = [];
    nodes.forEach(function(n){ vals.push(n.value); });
    return vals;
  }
  if (def.type === 'radio'){
    var nameR = 'grp_' + key;
    var picked = document.querySelector('input[name="'+nameR+'"]:checked');
    return picked ? picked.value : null;
  }

  // Einzel-Felder:
  var el = document.getElementById(id);
  if (!el) return null;

  if (def.type === 'range-1-5'){
    var n = Number(el.value);
    return (Number.isFinite(n) ? n : null);
  }
  if (def.type === 'number' || def.type === 'number-readonly'){
    var n2 = Number(el.value);
    return (Number.isFinite(n2) ? n2 : null);
  }
  if (def.type === 'tags'){
    var raw = String(el.value || '');
    return raw.split(',').map(function(s){ return s.trim(); }).filter(Boolean);
  }
  // text/textarea/date/url/select (string)
  return el.value != null ? String(el.value) : '';
}

// Werte aus dem Editor in ein neues Objekt mergen (auf Basis des Originalprofils)
function collectEditorValuesInto(originalProfileObj){
  var updated = deepClone(originalProfileObj || {});

  // Hilfsfunktionen
  function isEmptyVal(def, val){
    // was als "leer" gilt:
    if (val == null) return true;
    if (def.type === 'tags' || def.type === 'checkbox-group') return Array.isArray(val) && val.length === 0;
    if (typeof val === 'string') return val.trim() === '';
    return false;
  }
  function setAtPath(base, path, val){
    var parts = path.split('.');
    var cur = base;
    for (var i=0;i<parts.length-1;i++){
      var seg = parts[i];
      if (typeof cur[seg] !== 'object' || cur[seg] === null) cur[seg] = {};
      cur = cur[seg];
    }
    cur[parts[parts.length-1]] = val;
  }
  function deleteAtPath(base, path){
    var parts = path.split('.');
    var cur = base;
    for (var i=0;i<parts.length-1;i++){
      var seg = parts[i];
      if (!cur || typeof cur !== 'object') return;
      cur = cur[seg];
    }
    if (cur && typeof cur === 'object') delete cur[parts[parts.length-1]];
  }

  // Werte einsammeln und nur setzen, wenn:
  // - required ODER nicht leer
  (window.PROFILE_FIELDS || []).forEach(function(def){
    var val = readFieldValue(def);

    // Normalisieren
    if (def.type === 'range-1-5'){
      var n = Number(val);
      if (Number.isFinite(n)) val = Math.max(1, Math.min(5, n));
      else val = null;
    }
    if (def.type === 'tags'){
      if (!Array.isArray(val)) val = [];
    }
    if (def.type === 'checkbox-group'){
      if (!Array.isArray(val)) val = [];
    }

    if (def.required || !isEmptyVal(def, val)){
      setAtPath(updated, def.path, val);
    } else {
      // Optionale leere Werte entfernen (nicht senden)
      deleteAtPath(updated, def.path);
    }
  });

  // Alter (readonly) aus Geburtstag ableiten (nur setzen, wenn birthday da ist)
  try{
    var bd = updated && updated.profile && updated.profile.identity && updated.profile.identity.birthday;
    if (bd){
      var d = new Date(bd);
      if (!isNaN(+d)){
        var now = new Date();
        var age = now.getFullYear() - d.getFullYear();
        var m   = now.getMonth() - d.getMonth();
        if (m < 0 || (m === 0 && now.getDate() < d.getDate())) age--;
        if (!updated.profile.identity) updated.profile.identity = {};
        updated.profile.identity.age = age;
      } else {
        // ungültiges Datum → age entfernen, kein null senden
        if (updated.profile && updated.profile.identity) delete updated.profile.identity.age;
      }
    } else {
      if (updated.profile && updated.profile.identity) delete updated.profile.identity.age;
    }
  }catch(_e){}

  // Sicherstellen, dass Top-Level Pflicht-Schlüssel weiter vorhanden sind
  // (schema_version, profile_id, created_at, profile)
  if (!updated.schema_version) updated.schema_version = originalProfileObj && originalProfileObj.schema_version || 'user_profile.v1';
  if (!updated.profile_id)     updated.profile_id     = originalProfileObj && originalProfileObj.profile_id;
  if (!updated.created_at)     updated.created_at     = originalProfileObj && originalProfileObj.created_at || new Date().toISOString();
  if (!updated.profile)        updated.profile        = originalProfileObj && originalProfileObj.profile || {};

  return updated;
}
// Baut ein sauberes Import-Objekt (Whitelist + Normalisierung + Leeres entfernen)
function toImportEnvelope(src){
  const o = JSON.parse(JSON.stringify(src || {}));

  // Top-Level Whitelist
  const out = {
    schema_version: o.schema_version || 'user_profile.v1',
    profile_id: o.profile_id,
    created_at: o.created_at || new Date().toISOString(),
    profile: {}
  };

  const p = o.profile || {};
  const id = p.identity || {};
  const it = p.intent || {};
  const bh = p.behavior || {};
  const em = p.emotional || {};
  const inx= p.interests || {};

  function norm15(n){ n = Number(n); return Number.isFinite(n) ? Math.min(5, Math.max(1, Math.round(n))) : undefined; }
  function arr(v){ return Array.isArray(v) ? v.filter(Boolean) : undefined; }
  function str(v){ return (v == null || v === '') ? undefined : String(v); }

  out.profile.identity = {
    user_name:       str(id.user_name),
    gender:          str(id.gender),
    birthday:        str(id.birthday),
    age:             (typeof id.age === 'number' ? id.age : undefined),
    avatar_picture:  str(id.avatar_picture),
    system_language: str(id.system_language)
  };

  out.profile.intent = {
    expectations:        arr(it.expectations),
    biography:           str(it.biography),
    conversation_goals:  arr(it.conversation_goals),
    values_and_beliefs:  arr(it.values_and_beliefs),
    topics_to_avoid:     arr(it.topics_to_avoid)
  };

  out.profile.behavior = {
    social_energy:        arr(bh.social_energy),
    communication_style:  arr(bh.communication_style),
    conflict_response:    str(bh.conflict_response),
    support_style:        str(bh.support_style),
    assertiveness_level:  norm15(bh.assertiveness_level),
    decision_style:       str(bh.decision_style)
  };

  out.profile.emotional = {
    emotional_needs:      arr(em.emotional_needs),
    maintenance_style:    arr(em.maintenance_style),
    emotional_regulation: str(em.emotional_regulation),
    empathy_depth:        norm15(em.empathy_depth),
    stress_tolerance:     norm15(em.stress_tolerance)
  };

  out.profile.interests = {
    shared_lifestyle_type: arr(inx.shared_lifestyle_type),
    interests:             arr(inx.interests)
  };

  // Leere/undefinierte Werte entfernen (rekursiv)
  function prune(obj){
    if (!obj || typeof obj !== 'object') return obj;
    Object.keys(obj).forEach(k=>{
      const v = obj[k];
      if (v && typeof v === 'object') prune(v);

      const isEmptyArray = Array.isArray(obj[k]) && obj[k].length === 0;
      const isEmptyObj   = (obj[k] && typeof obj[k] === 'object' && !Array.isArray(obj[k]) && Object.keys(obj[k]).length === 0);

      if (v === undefined || v === null || v === '' || isEmptyArray || isEmptyObj){
        delete obj[k];
      }
    });
    return obj;
  }

  return prune(out);
}
// Preflight: prüft die NDJSON-Hülle & minimale Pflichtstruktur
function preflightImportCheck(obj){
  const errors = [];

  // 1) Top-Level Pflichtfelder
  if (!obj || typeof obj !== 'object') errors.push('payload must be an object');
  if (!obj.schema_version) errors.push('schema_version missing');
  if (!obj.profile_id)     errors.push('profile_id missing');
  if (!obj.created_at)     errors.push('created_at missing');
  if (!obj.profile || typeof obj.profile !== 'object') errors.push('profile missing');

  // 2) Pflicht-Abschnitte innerhalb profile
  const sec = obj.profile || {};
  ['identity','intent','behavior','emotional','interests'].forEach(k=>{
    if (!sec[k] || typeof sec[k] !== 'object') errors.push('profile.'+k+' missing');
  });

  // 3) Minimalfelder, die fast immer gefordert werden
  if (!sec.identity || typeof sec.identity.user_name !== 'string' || !sec.identity.user_name.trim()){
    errors.push('profile.identity.user_name missing');
  }

  // 4) Bei Scale-/Radio-Pflichtfeldern auf Typ prüfen (falls vorhanden)
  function is1to5(n){ return typeof n === 'number' && n>=1 && n<=5; }
  if (sec.behavior){
    if (sec.behavior.assertiveness_level!=null && !is1to5(sec.behavior.assertiveness_level)){
      errors.push('behavior.assertiveness_level must be 1..5');
    }
    if (sec.behavior.decision_style!=null && typeof sec.behavior.decision_style !== 'string'){
      errors.push('behavior.decision_style must be string');
    }
  }
  if (sec.emotional){
    if (sec.emotional.empathy_depth!=null && !is1to5(sec.emotional.empathy_depth)){
      errors.push('emotional.empathy_depth must be 1..5');
    }
    if (sec.emotional.stress_tolerance!=null && !is1to5(sec.emotional.stress_tolerance)){
      errors.push('emotional.stress_tolerance must be 1..5');
    }
    if (sec.emotional.emotional_regulation!=null && typeof sec.emotional.emotional_regulation !== 'string'){
      errors.push('emotional.emotional_regulation must be string');
    }
  }

  // 5) Checkbox-Gruppen: wenn vorhanden, müssen Arrays sein
  const mustBeArrays = [
    'intent.expectations','intent.conversation_goals','intent.values_and_beliefs','intent.topics_to_avoid',
    'behavior.social_energy','behavior.communication_style',
    'emotional.emotional_needs','emotional.maintenance_style',
    'interests.shared_lifestyle_type','interests.interests'
  ];
  mustBeArrays.forEach(path=>{
    const parts = path.split('.');
    let cur = sec;
    for (const p of parts){
      if (!cur || typeof cur !== 'object'){ cur = undefined; break; }
      cur = cur[p];
    }
    if (cur != null && !Array.isArray(cur)){
      errors.push('profile.'+path+' must be array');
    }
  });

  return { ok: errors.length===0, errors };
}

// Required-Validierung anhand der Felddefinitionen
function validateProfileRequired(updatedObj){
  var errors = [];

  function hasAny(arr){ return Array.isArray(arr) && arr.length > 0; }
  function nonEmpty(str){ return typeof str === 'string' && str.trim().length > 0; }
  function getAt(obj, path){
    var parts = path.split('.');
    var cur = obj;
    for (var i=0;i<parts.length;i++){
      var k = parts[i];
      if (!cur || !(k in cur)) return undefined;
      cur = cur[k];
    }
    return cur;
  }

  (window.PROFILE_FIELDS || []).forEach(function(def){
    if (!def.required) return; // nur Pflichtfelder prüfen
    var val = getAt(updatedObj, def.path);

    if (def.type === 'checkbox-group'){
      if (!hasAny(val)) errors.push(def.key + ' (choose at least one)');
      return;
    }
    if (def.type === 'range-1-5'){
      var ok = (typeof val === 'number') && val >= 1 && val <= 5;
      if (!ok) errors.push(def.key + ' (1–5)');
      return;
    }
    if (def.type === 'radio' || def.type === 'select'){
      if (val == null || val === '') errors.push(def.key + ' (required)');
      return;
    }
    // text/textarea/tags/date etc. – nur wenn als required markiert
    if (val == null || (typeof val === 'string' && !nonEmpty(val))) {
      // Für 'tags' erlauben wir leere Arrays nicht, wenn required
      if (def.type === 'tags'){
        if (!hasAny(val)) errors.push(def.key + ' (required)');
      } else {
        errors.push(def.key + ' (required)');
      }
    }
  });

  return { ok: errors.length === 0, errors: errors };
}

// Persist: Versuche Upsert-API; bei 404 fallback auf lokalen Cache
    async function persistProfileUpdate(updatedObj){
        // --- SANITIZER: Whitelist-Struktur + Null/Empty-Filter ---
    function pruneEmpty(v){
      if (v === null || v === undefined) return undefined;
      if (typeof v === 'string' && v.trim() === '') return undefined;
      if (Array.isArray(v)) {
        const arr = v.map(pruneEmpty).filter(x => x !== undefined);
        return arr.length ? arr : undefined;
      }
      if (typeof v === 'object') {
        const o = {};
        Object.keys(v).forEach(k => {
          const pv = pruneEmpty(v[k]);
          if (pv !== undefined) o[k] = pv;
        });
        return Object.keys(o).length ? o : undefined;
      }
      return v;
    }

    function toImportEnvelope(src){
      // Whitelist-Shape exakt wie Generator es baut
      const id    = src && src.profile_id;
      const sv    = src && src.schema_version || 'user_profile.v1';
      const ca    = src && src.created_at || new Date().toISOString();
      const p     = src && src.profile || {};

      const out = {
        schema_version: String(sv),
        profile_id: String(id || ''),
        created_at: String(ca),
        profile: {
          identity:  {
            user_name:      p.identity && p.identity.user_name || '',
            gender:         p.identity && p.identity.gender || undefined,
            birthday:       p.identity && p.identity.birthday || undefined,
            age:            (p.identity && typeof p.identity.age === 'number') ? p.identity.age : undefined,
            avatar_picture: p.identity && p.identity.avatar_picture || undefined,
            system_language:p.identity && p.identity.system_language || undefined
          },
          intent: {
            expectations:        p.intent && p.intent.expectations || [],
            biography:           p.intent && p.intent.biography || undefined,
            conversation_goals:  p.intent && p.intent.conversation_goals || [],
            values_and_beliefs:  p.intent && p.intent.values_and_beliefs || [],
            topics_to_avoid:     p.intent && p.intent.topics_to_avoid || []
          },
          behavior: {
            social_energy:       p.behavior && p.behavior.social_energy || [],
            communication_style: p.behavior && p.behavior.communication_style || [],
            conflict_response:   p.behavior && p.behavior.conflict_response || undefined,
            support_style:       p.behavior && p.behavior.support_style || undefined,
            assertiveness_level: p.behavior && p.behavior.assertiveness_level || undefined,
            decision_style:      p.behavior && p.behavior.decision_style || undefined
          },
          emotional: {
            emotional_needs:     p.emotional && p.emotional.emotional_needs || [],
            maintenance_style:   p.emotional && p.emotional.maintenance_style || [],
            emotional_regulation:p.emotional && p.emotional.emotional_regulation || undefined,
            empathy_depth:       p.emotional && p.emotional.empathy_depth || undefined,
            stress_tolerance:    p.emotional && p.emotional.stress_tolerance || undefined
          },
          interests: {
            shared_lifestyle_type: p.interests && p.interests.shared_lifestyle_type || [],
            interests:              p.interests && p.interests.interests || []
          }
        }
      };

      // Alles leere/undefined entfernen (aber Pflichtfelder behalten)
      const pruned = pruneEmpty(out);

      // Pflichtfelder final absichern
      if (!pruned.schema_version) pruned.schema_version = 'user_profile.v1';
      if (!pruned.profile_id)     pruned.profile_id     = String(src.profile_id || '');
      if (!pruned.created_at)     pruned.created_at     = new Date().toISOString();
      pruned.profile = pruned.profile || {};
      pruned.profile.identity  = pruned.profile.identity  || {};
      pruned.profile.intent    = pruned.profile.intent    || {};
      pruned.profile.behavior  = pruned.profile.behavior  || {};
      pruned.profile.emotional = pruned.profile.emotional || {};
      pruned.profile.interests = pruned.profile.interests || {};

      return pruned;
    }
  try{
        // 0) Preflight auf dem gereinigten Objekt (Whitelist + Null/Empty-Felder entfernt)
    const payload = toImportEnvelope(updatedObj);
    // Debug: check profile sections
    console.log('[profiles.save] payload.profile', JSON.stringify(payload.profile, null, 2));

    // Fix: ensure all sections exist even if empty
    ['intent','behavior','emotional','interests'].forEach(sec => {
      if (!payload.profile[sec] || typeof payload.profile[sec] !== 'object') {
        payload.profile[sec] = {};
      }
    });
    const pf = preflightImportCheck(payload);
    if (!pf.ok){
      console.warn('[preflight errors]', pf.errors);
      return { ok:false, error:'Preflight failed: ' + pf.errors.join(', ') };
    }

    // 1) Sichtbares Debug: Was schicken wir wirklich? (bereinigtes Payload)
    console.log('[profiles.save] payload', payload);

    // 1b) Harte Normalisierung für Import
    function clamp15(n){ n = Number(n); return (Number.isFinite(n) ? Math.min(5, Math.max(1, Math.round(n))) : undefined); }
    if (payload.profile && payload.profile.behavior){
      if (payload.profile.behavior.assertiveness_level != null) {
        payload.profile.behavior.assertiveness_level = clamp15(payload.profile.behavior.assertiveness_level);
      }
    }
    if (payload.profile && payload.profile.emotional){
      if (payload.profile.emotional.empathy_depth != null) {
        payload.profile.emotional.empathy_depth = clamp15(payload.profile.emotional.empathy_depth);
      }
      if (payload.profile.emotional.stress_tolerance != null) {
        payload.profile.emotional.stress_tolerance = clamp15(payload.profile.emotional.stress_tolerance);
      }
    }

    // required-Gruppen dürfen NICHT leer sein – sonst abbrechen:
    const reqArrays = [
      ['profile','intent','expectations'],
      ['profile','intent','conversation_goals'],
      ['profile','intent','values_and_beliefs'],
      ['profile','behavior','social_energy'],
      ['profile','behavior','communication_style'],
      ['profile','emotional','emotional_needs'],
      ['profile','emotional','maintenance_style'],
      ['profile','interests','shared_lifestyle_type'],
      ['profile','interests','interests']
    ];
    for (const path of reqArrays){
      let cur = payload;
      for (const seg of path) cur = (cur && cur[seg]) || undefined;
      if (!Array.isArray(cur) || cur.length === 0){
        return { ok:false, error:'Preflight failed: some required multi-selects are empty' };
      }
    }

    // user_name Pflicht (zur Not = profile_id)
    if (!payload.profile.identity.user_name) {
      payload.profile.identity.user_name = payload.profile_id || '';
    }

    console.log('[profiles.save] import payload', payload);

    // 2) NDJSON-Zeile aus bereinigtem Payload bauen
    const ndj = JSON.stringify(payload) + '\n';
    const token = (typeof authTokenEl !== 'undefined' && authTokenEl && authTokenEl.value) ? authTokenEl.value : 'admin_local';

    // 3) Import-Endpoint (Server unterstützt PUT nicht → 405)
    const res = await fetch('/api/profiles/import', {
      method: 'POST',
      headers: {
        'Authorization': 'Bearer ' + token,
        'Content-Type': 'application/x-ndjson'
      },
      body: ndj
    });

    if (res.ok) return { ok:true };

    // 422 → zeige Servertext
    if (res.status === 422){
      let detail = '';
      try { detail = await res.text(); } catch(_e){}
      return { ok:false, error: 'HTTP 422 — ' + (detail || 'Validation failed') };
    }

    // 404/405 → Fallback lokal (bis Upsert existiert)
    if (res.status === 404 || res.status === 405){
      const idx = (window.ALL_PROFILES || []).findIndex(p => p.profile_id === updatedObj.profile_id);
      if (idx >= 0) {
        window.ALL_PROFILES[idx] = updatedObj;
        if (typeof applyFilterAndRender === 'function') applyFilterAndRender();
        return { ok:true, localOnly:true };
      }
      return { ok:false, error:'HTTP ' + res.status + ' (and local cache not found)' };
    }

    return { ok:false, error:'HTTP ' + res.status };
  } catch (e){
    return { ok:false, error:String(e && e.message ? e.message : e) };
  }
}
// Verkabelung der Buttons im Lightbox-Editor (Cancel/Save)
function wireProfileEditor(profileObj){
  var root = document.getElementById('lb-root');
  if (!root) return;

  var btnCancel = root.querySelector('#btnEditorCancel');
  if (btnCancel) btnCancel.addEventListener('click', closeLightbox);

  var btnSave = root.querySelector('#btnEditorSave');
  if (btnSave) btnSave.addEventListener('click', async function(){
    // 1) Einsammeln
    var updated = collectEditorValuesInto(profileObj);
    // 2) Validieren
    var check = validateProfileRequired(updated);
    if (!check.ok){
      alert('Please fix required fields:\n\n• ' + check.errors.join('\n• '));
      return;
    }
    // 3) Persistieren
    var res = await persistProfileUpdate(updated);
    if (!res.ok){
      alert('Save failed: ' + (res.error || 'unknown error'));
      return;
    }
    // 4) Zu & UI aktualisieren (applyFilterAndRender schon im Fallback)
    closeLightbox();
    // Falls Upsert ok war, frische Ansicht
    if (!res.localOnly && typeof applyFilterAndRender === 'function'){
      // ersetze das Profil auch im Cache, falls vorhanden
      var idx = (window.ALL_PROFILES || []).findIndex(function(p){ return p.profile_id === updated.profile_id; });
      if (idx >= 0) window.ALL_PROFILES[idx] = updated;
      applyFilterAndRender();
    }
  });
}

    // Cards
    function renderCards(list){
      SELECTED_IDS.clear();
      updateToolbar();

      if (!list.length){
        cardsEl.innerHTML = '<div class="muted">No profiles match the current filters.</div>';
        return;
      }

      const rows = list.map(function(p){
        const id  = p.profile_id;
        const nm  = (p && p.profile && p.profile.identity && p.profile.identity.user_name) ? p.profile.identity.user_name : id;
        const a   = (p && p.profile && p.profile.behavior && p.profile.behavior.assertiveness_level != null) ? p.profile.behavior.assertiveness_level : '–';
        const em  = (p && p.profile && p.profile.emotional && p.profile.emotional.empathy_depth != null) ? p.profile.emotional.empathy_depth : '–';
        const st  = (p && p.profile && p.profile.emotional && p.profile.emotional.stress_tolerance != null) ? p.profile.emotional.stress_tolerance : '–';
        const reg = (p && p.profile && p.profile.emotional && p.profile.emotional.emotional_regulation != null) ? p.profile.emotional.emotional_regulation : '–';
        const title = nm + ' (' + id + ')';
        const chatChecked = CHAT_ENABLED_IDS.has(id) ? 'checked' : '';
        return '' +
        '<tr data-id="' + id + '">' +
          '<td style="width:36px;"><input type="checkbox" class="rowSelect" data-id="' + id + '"></td>' +
          '<td title="' + escapeHtml(title) + '"><strong>' + escapeHtml(nm) + '</strong></td>' +
          '<td class="badge-meta">' + escapeHtml(id) + '</td>' +
          '<td class="badge-meta">A:' + a + ' • E:' + em + ' • S:' + st + ' • ' + reg + '</td>' +
          '<td style="text-align:center; width:78px;">' +
            '<input type="checkbox" class="rowChat" data-id="' + id + '" ' + chatChecked + ' aria-label="Enable for Chat">' +
          '</td>' +
          '<td class="actions" style="text-align:right;">' +
            '<a href="#" data-act="view" data-id="' + id + '">View</a>' +
            '<a href="#" data-act="edit" data-id="' + id + '">Edit</a>' +
            '<a href="#" data-act="delete" data-id="' + id + '" aria-disabled="true" style="opacity:.5; pointer-events:none;">Delete</a>' +
          '</td>' +
        '</tr>';
      }).join('');

      cardsEl.innerHTML =
        '<table class="table-profiles">' +
          '<thead>' +
            '<tr>' +
              '<th style="width:34px;"><input type="checkbox" id="selectAll"></th>' +
              '<th>Name</th>' +
              '<th>ID</th>' +
              '<th>Meta (A/E/S • Regulation)</th>' +
              '<th style="width:78px; text-align:center;">Chat</th>' +
              '<th>Actions</th>' +
            '</tr>' +
          '</thead>' +
          '<tbody>' + rows + '</tbody>' +
        '</table>';

      const headMaster = cardsEl.querySelector('#selectAll');
      if (headMaster) headMaster.addEventListener('change', function(){
        const cbs = cardsEl.querySelectorAll('.rowSelect');
        SELECTED_IDS.clear();
        cbs.forEach(function(cb){
          cb.checked = headMaster.checked;
          if (headMaster.checked) SELECTED_IDS.add(cb.dataset.id);
        });
        updateToolbar();
      });

      cardsEl.querySelectorAll('.rowSelect').forEach(function(cb){
        cb.addEventListener('change', function(e){
          const id = e.currentTarget.dataset.id;
          if (e.currentTarget.checked) SELECTED_IDS.add(id);
          else SELECTED_IDS.delete(id);
          updateToolbar();
          syncMasterCheckbox();
        });
      });

      cardsEl.querySelectorAll('.rowChat').forEach(function(cb){
        cb.addEventListener('change', async function(e){
          const id = e.currentTarget.dataset.id;
          if (e.currentTarget.checked) {
            CHAT_ENABLED_IDS.add(id);
            if (!CHAT_MAP.has(id)) {
              try {
                const obj = await apiItem(id);
                CHAT_MAP.set(id, obj);
              } catch (err) {
                console.warn('Load for chat failed', err);
                CHAT_ENABLED_IDS.delete(id);
                e.currentTarget.checked = false;
                return;
              }
            }
          } else {
            CHAT_ENABLED_IDS.delete(id);
            CHAT_MAP.delete(id);
          }
          if (chatEnabledInfo) chatEnabledInfo.textContent = String(CHAT_ENABLED_IDS.size);
          syncChatLocalStorage();
        });
      });

      cardsEl.querySelectorAll('a[data-act]').forEach(function(a){
        a.addEventListener('click', async function(e){
          e.preventDefault();
          const act = e.currentTarget.dataset.act;
          const id  = e.currentTarget.dataset.id;

          if (act === 'view'){
            apiItem(id).then(function(obj){
              alert('Profile ' + id + '\n\n' + JSON.stringify(obj,null,2));
            }).catch(function(err){ alert('Load failed: ' + (err && err.message ? err.message : err)); });
            return;
          }

          if (act === 'edit'){
            try {
              const obj = await apiItem(id);
              const html = buildProfileEditorHTML(obj);
              openLightboxWith(html);
              wireProfileEditor(obj);
            // --- Section Toggle + Expand/Collapse all ---
            const lbRoot = document.getElementById('lb-root');
            const dlg    = lbRoot ? lbRoot.querySelector('.lb-dialog') : null;
            if (dlg) {
              // 1) Default: alle Sections zuklappen
              const sections = dlg.querySelectorAll('.editor-section');
              sections.forEach(sec => sec.classList.add('collapsed'));

              // 2) Single-Section Toggle
              dlg.addEventListener('click', function(e){
                const h = e.target;
                if (h && h.tagName === 'H3' && h.closest('.editor-section')) {
                  const sec = h.closest('.editor-section');
                  sec.classList.toggle('collapsed');
                }
              });

              // 3) Expand/Collapse all
              const btnAll = dlg.querySelector('#btnExpandAll');
              if (btnAll) {
                btnAll.addEventListener('click', function(){
                  const anyCollapsed = Array.prototype.some.call(sections, function(sec){
                    return sec.classList.contains('collapsed');
                  });
                  sections.forEach(function(sec){
                    sec.classList.toggle('collapsed', !anyCollapsed);
                  });
                  btnAll.textContent = anyCollapsed ? 'Collapse all' : 'Expand all';
                });
              }
            }
            // --- END Section Toggle ---
            } catch (err) {
              console.error('[Edit] load failed:', err);
              alert('Could not load profile for editing.');
            }
            return;
          }
        });
      });

      if (chkSelectAll) chkSelectAll.checked = false;
      updateToolbar();
    }

    function updateToolbar(){
      const count = SELECTED_IDS.size;
      if (bulkCountEl) bulkCountEl.textContent = String(count);
      if (btnBulkDelete) btnBulkDelete.disabled = true;
      syncMasterCheckbox();
      if (chatEnabledInfo) chatEnabledInfo.textContent = String(CHAT_ENABLED_IDS.size);
    }

    function syncMasterCheckbox(){
      const master = document.querySelector('#selectAll');
      if (!master) return;
      const tbody = document.querySelector('#cards tbody');
      if (!tbody) { master.checked = false; master.indeterminate = false; return; }

      const rowCbs = Array.from(tbody.querySelectorAll('.rowSelect'));
      const total  = rowCbs.length;
      const checked = rowCbs.filter(function(cb){ return cb.checked; }).length;

      if (checked === 0){
        master.checked = false;
        master.indeterminate = false;
      } else if (checked === total){
        master.checked = true;
        master.indeterminate = false;
      } else {
        master.checked = false;
        master.indeterminate = true;
      }
    }

    if (chkSelectAll) chkSelectAll.addEventListener('change', function(){
      const tbody = cardsEl.querySelector('tbody');
      if (!tbody) return;
      const cbs = Array.from(tbody.querySelectorAll('.rowSelect'));
      SELECTED_IDS.clear();
      cbs.forEach(function(cb){
        cb.checked = chkSelectAll.checked;
        if (chkSelectAll.checked) SELECTED_IDS.add(cb.dataset.id);
      });
      updateToolbar();
    });

    if (btnBulkDelete) btnBulkDelete.addEventListener('click', function(){
      alert('Bulk delete: not yet implemented in prototype.');
    });

    // Upload
    if (btnGenUp) btnGenUp.addEventListener('click', async function(){
      try{
        const n = Math.max(1, Math.min(2000, Number(genCountEl.value || '25')));
        const token = authTokenEl.value || 'admin_local';
        const ndj = toNDJSON(generateProfiles(n));
        setStatus('Uploading generated profiles…');
        const res = await apiImportNDJSON(ndj, token);
        const ok = res.ok, status = res.status, body = res.body || {};
        setStatus(ok ? 'OK (' + status + ') — stored: ' + (body.profiles_stored || 0) : 'Error (' + status + ')');
        if (ok) afterImport(body);
      }catch(e){ setStatus('Error: ' + (e && e.message ? e.message : e)); }
    });

    if (btnUpFile) btnUpFile.addEventListener('click', async function(){
      const f = fileInput.files && fileInput.files[0];
      if(!f){ setStatus('Please choose a .ndjson file'); return; }
      const token = authTokenEl.value || 'admin_local';
      try{
        setStatus('Uploading ' + f.name + '…');
        const text = await f.text();
        const res = await apiImportNDJSON(text, token);
        const ok = res.ok, status = res.status, body = res.body || {};
        setStatus(ok ? 'OK (' + status + ') — stored: ' + (body.profiles_stored || 0) : 'Error (' + status + ')');
        if (ok) afterImport(body);
      }catch(e){ setStatus('Error: ' + (e && e.message ? e.message : e)); }
    });

    function setStatus(msg){ if(uploadStatus) uploadStatus.textContent = 'Status: ' + msg; }
    function afterImport(body){
      if (body && body.import_id) lastImportEl.textContent = body.import_id;
      document.dispatchEvent(new CustomEvent('profileUploadComplete',{ detail: body }));
      loadData();
    }

    // Controls
    function initControls(){
      function wrap(el,lbl){
        if (!el || !lbl) return;
        el.addEventListener('input', function(){
          lbl.textContent = (el.value === '0' ? 'any' : el.value);
          applyFilterAndRender();
        });
      }
      wrap(slAssert, valAssert); wrap(slEmpathy, valEmp); wrap(slStress, valStress);
      chkRegs.forEach(function(cb){ cb.addEventListener('change', applyFilterAndRender); });
      if (btnResetFilters) btnResetFilters.addEventListener('click', function(){
        slAssert.value='0'; valAssert.textContent='any';
        slEmpathy.value='0'; valEmp.textContent='any';
        slStress.value='0';  valStress.textContent='any';
        chkRegs.forEach(function(c){ c.checked=true; });
        applyFilterAndRender();
      });
      if (filtersEnabled) filtersEnabled.addEventListener('change', applyFilterAndRender);
    }

    // Boot
    window.addEventListener('DOMContentLoaded', function(){
      initChatFromLocal();
      if (chatEnabledInfo) chatEnabledInfo.textContent = String(CHAT_ENABLED_IDS.size);
      if (filtersEnabled) filtersEnabled.checked = false;
      if (slAssert && valAssert) valAssert.textContent = slAssert.value==='0' ? 'any' : slAssert.value;
      if (slEmpathy && valEmp)  valEmp.textContent    = slEmpathy.value==='0' ? 'any' : slEmpathy.value;
      if (slStress && valStress)valStress.textContent = slStress.value==='0' ? 'any' : slStress.value;

      initControls();
      refreshKVCountOnly().catch(console.error);
      initChatFromLocal();
      if (chatEnabledInfo) chatEnabledInfo.textContent = String(CHAT_ENABLED_IDS.size);
      loadData().catch(console.error);
    });
  </script>
</body>
</html>